// Code generated by protoc-gen-go.
// source: github.com/richard28530/streaming_telemetry/rpc/gnmi.proto
// DO NOT EDIT!

/*
Package smetric_rpc is a generated protocol buffer package.

Package gNMI defines a service specification for the gRPC Network Management
Interface. This interface is defined to be a standard interface via which
a network management system ("client") can subscribe to state values,
retrieve snapshots of state information, and manipulate the state of a data
tree supported by a device ("target").

This document references the gNMI Specification which can be found at
http://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi.md

It is generated from these files:
	github.com/richard28530/streaming_telemetry/rpc/gnmi.proto

It has these top-level messages:
	ModelData
	Notification
	Update
	Path
	Value
	Error
	SubscribeRequest
	Poll
	Heartbeat
	SubscribeResponse
	SubscriptionList
	Subscription
	QOSMarking
	Alias
	AliasList
	UDPWrapper
*/
package smetric_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"
import google_protobuf1 "github.com/golang/protobuf/protoc-gen-go/descriptor"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Encoding defines the value encoding formats that are supported by the gNMI
// protocol. These encodings are used by both the client (when sending Set
// messages to modify the state of the target) and the target when serializing
// data to be returned to the client (in both Subscribe and Get RPCs).
// Reference: gNMI Specification Section 2.3
type Encoding int32

const (
	Encoding_JSON      Encoding = 0
	Encoding_BYTES     Encoding = 1
	Encoding_PROTO     Encoding = 2
	Encoding_ASCII     Encoding = 3
	Encoding_JSON_IETF Encoding = 4
)

var Encoding_name = map[int32]string{
	0: "JSON",
	1: "BYTES",
	2: "PROTO",
	3: "ASCII",
	4: "JSON_IETF",
}
var Encoding_value = map[string]int32{
	"JSON":      0,
	"BYTES":     1,
	"PROTO":     2,
	"ASCII":     3,
	"JSON_IETF": 4,
}

func (x Encoding) String() string {
	return proto.EnumName(Encoding_name, int32(x))
}
func (Encoding) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// SubscriptionMode is the mode of the subscription, specifying how the
// target must return values in a subscription.
// Reference: gNMI Specification Section 3.5.1.3
type SubscriptionMode int32

const (
	SubscriptionMode_TARGET_DEFINED SubscriptionMode = 0
	SubscriptionMode_ON_CHANGE      SubscriptionMode = 1
	SubscriptionMode_SAMPLE         SubscriptionMode = 2
)

var SubscriptionMode_name = map[int32]string{
	0: "TARGET_DEFINED",
	1: "ON_CHANGE",
	2: "SAMPLE",
}
var SubscriptionMode_value = map[string]int32{
	"TARGET_DEFINED": 0,
	"ON_CHANGE":      1,
	"SAMPLE":         2,
}

func (x SubscriptionMode) String() string {
	return proto.EnumName(SubscriptionMode_name, int32(x))
}
func (SubscriptionMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// SubscriptionOperation is the operation of the subscription, sepcifying
// if is subscribe or subscibe_cancel
type SubscriptionOperation int32

const (
	SubscriptionOperation_SUBSCRIBE_ADD    SubscriptionOperation = 0
	SubscriptionOperation_SUBSCRIBE_CANCEL SubscriptionOperation = 1
)

var SubscriptionOperation_name = map[int32]string{
	0: "SUBSCRIBE_ADD",
	1: "SUBSCRIBE_CANCEL",
}
var SubscriptionOperation_value = map[string]int32{
	"SUBSCRIBE_ADD":    0,
	"SUBSCRIBE_CANCEL": 1,
}

func (x SubscriptionOperation) String() string {
	return proto.EnumName(SubscriptionOperation_name, int32(x))
}
func (SubscriptionOperation) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Mode of the subscription.
type SubscriptionList_Mode int32

const (
	SubscriptionList_STREAM SubscriptionList_Mode = 0
	SubscriptionList_ONCE   SubscriptionList_Mode = 1
	SubscriptionList_POLL   SubscriptionList_Mode = 2
)

var SubscriptionList_Mode_name = map[int32]string{
	0: "STREAM",
	1: "ONCE",
	2: "POLL",
}
var SubscriptionList_Mode_value = map[string]int32{
	"STREAM": 0,
	"ONCE":   1,
	"POLL":   2,
}

func (x SubscriptionList_Mode) String() string {
	return proto.EnumName(SubscriptionList_Mode_name, int32(x))
}
func (SubscriptionList_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

// ModelData is used to describe a set of schema modules. It can be used in a
// CapabilityResponse where a target reports the set of modules that it
// supports, and within the SubscribeRequest and GetRequest messages to specify
// the set of models from which data tree elements should be reported.
// Reference: gNMI Specification Section 3.2.3
type ModelData struct {
	Name         string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Organization string `protobuf:"bytes,2,opt,name=organization" json:"organization,omitempty"`
	Version      string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ModelData) Reset()                    { *m = ModelData{} }
func (m *ModelData) String() string            { return proto.CompactTextString(m) }
func (*ModelData) ProtoMessage()               {}
func (*ModelData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ModelData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelData) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *ModelData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Notification is a re-usable message that is used to encode data from the
// target to the client. A Notification carries two types of changes to the data
// tree:
//  - Deleted values (delete) - a set of paths that have been removed from the
//    data tree.
//  - Updated values (update) - a set of path-value pairs indicating the path
//    whose value has changed in the data tree.
// Reference: gNMI Specification Section 2.1
type Notification struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Prefix    *Path `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	// An alias for the path specified in the prefix field.
	// Reference: gNMI Specification Section 2.4.2
	Alias  string    `protobuf:"bytes,3,opt,name=alias" json:"alias,omitempty"`
	Update []*Update `protobuf:"bytes,4,rep,name=update" json:"update,omitempty"`
	Delete []*Path   `protobuf:"bytes,5,rep,name=delete" json:"delete,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Notification) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Notification) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *Notification) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Notification) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

// Update is a re-usable message that is used to store a particular Path,
// Value pair.
// Reference: gNMI Specification Section 2.1
type Update struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Update) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Update) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Path encodes a data tree path as a series of repeated strings, with
// each element of the path representing a data tree node name and the
// associated attributes.
// Reference: gNMI Specification Section 2.2.2.
type Path struct {
	Element []string `protobuf:"bytes,1,rep,name=element" json:"element,omitempty"`
	Origin  string   `protobuf:"bytes,2,opt,name=origin" json:"origin,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Path) GetElement() []string {
	if m != nil {
		return m.Element
	}
	return nil
}

func (m *Path) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

// Value encodes a data tree node's value - along with the way in which
// the value is encoded.
// Reference: gNMI Specification Section 2.2.3.
type Value struct {
	Value []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  Encoding `protobuf:"varint,2,opt,name=type,enum=smetric_rpc.Encoding" json:"type,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Value) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetType() Encoding {
	if m != nil {
		return m.Type
	}
	return Encoding_JSON
}

// Error message used by the target to return errors to the client.
// Reference: gNMI Specification Section 2.5
type Error struct {
	Code    uint32               `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Data    *google_protobuf.Any `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetData() *google_protobuf.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

// SubscribeRequest is the message sent by the client to the target when
// initiating a subscription to a set of paths within the data tree. The
// request field must be populated and the initial message must specify a
// SubscriptionList to initiate a subscription. The message is subsequently
// used to define aliases or trigger polled data to be sent by the target.
// Reference: gNMI Specification Section 3.5.1.1
type SubscribeRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SubscribeRequest_Subscribe
	//	*SubscribeRequest_Heartbeat
	//	*SubscribeRequest_Poll
	//	*SubscribeRequest_Aliases
	Request isSubscribeRequest_Request `protobuf_oneof:"request"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isSubscribeRequest_Request interface {
	isSubscribeRequest_Request()
}

type SubscribeRequest_Subscribe struct {
	Subscribe *SubscriptionList `protobuf:"bytes,1,opt,name=subscribe,oneof"`
}
type SubscribeRequest_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeRequest_Poll struct {
	Poll *Poll `protobuf:"bytes,3,opt,name=poll,oneof"`
}
type SubscribeRequest_Aliases struct {
	Aliases *AliasList `protobuf:"bytes,4,opt,name=aliases,oneof"`
}

func (*SubscribeRequest_Subscribe) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Heartbeat) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Poll) isSubscribeRequest_Request()      {}
func (*SubscribeRequest_Aliases) isSubscribeRequest_Request()   {}

func (m *SubscribeRequest) GetRequest() isSubscribeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SubscribeRequest) GetSubscribe() *SubscriptionList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *SubscribeRequest) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetRequest().(*SubscribeRequest_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeRequest) GetPoll() *Poll {
	if x, ok := m.GetRequest().(*SubscribeRequest_Poll); ok {
		return x.Poll
	}
	return nil
}

func (m *SubscribeRequest) GetAliases() *AliasList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Aliases); ok {
		return x.Aliases
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeRequest_OneofMarshaler, _SubscribeRequest_OneofUnmarshaler, _SubscribeRequest_OneofSizer, []interface{}{
		(*SubscribeRequest_Subscribe)(nil),
		(*SubscribeRequest_Heartbeat)(nil),
		(*SubscribeRequest_Poll)(nil),
		(*SubscribeRequest_Aliases)(nil),
	}
}

func _SubscribeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *SubscribeRequest_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeRequest_Poll:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Poll); err != nil {
			return err
		}
	case *SubscribeRequest_Aliases:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aliases); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SubscribeRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SubscribeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeRequest)
	switch tag {
	case 1: // request.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubscriptionList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Subscribe{msg}
		return true, err
	case 2: // request.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Heartbeat{msg}
		return true, err
	case 3: // request.poll
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Poll)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Poll{msg}
		return true, err
	case 4: // request.aliases
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Aliases{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		s := proto.Size(x.Subscribe)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Poll:
		s := proto.Size(x.Poll)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Aliases:
		s := proto.Size(x.Aliases)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Poll is sent within a SubscribeRequest to trigger the device to
// send telemetry updates for the paths that are associated with the
// subscription.
// Reference: gNMI Specification Section Section 3.5.1.4
type Poll struct {
}

func (m *Poll) Reset()                    { *m = Poll{} }
func (m *Poll) String() string            { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()               {}
func (*Poll) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// A Heartbeat requests a (possibly repeated) response from the remote side.
type Heartbeat struct {
	// interval is the maximum amount of time, in nanoseconds, between subsequent
	// messages from the remote side.  An empty message may be sent if no other
	// messages are pending.  If interval is 0 then the remote must immediately
	// respond with a (possibly empty) message.
	Interval uint64 `protobuf:"varint,1,opt,name=interval" json:"interval,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Heartbeat) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

// SubscribeResponse is the message used by the target within a Subscribe RPC.
// The target includes a Notification message which is used to transmit values
// of the path(s) that are associated with the subscription. The same message
// is to indicate that the target has sent all data values once (is
// synchronized). The error field is used to report errors that occur during
// creation of a subscription.
// Reference: gNMI Specification Section 3.5.1.4
type SubscribeResponse struct {
	// Types that are valid to be assigned to Response:
	//	*SubscribeResponse_Update
	//	*SubscribeResponse_Heartbeat
	//	*SubscribeResponse_SyncResponse
	//	*SubscribeResponse_Error
	Response isSubscribeResponse_Response `protobuf_oneof:"response"`
}

func (m *SubscribeResponse) Reset()                    { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()               {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isSubscribeResponse_Response interface {
	isSubscribeResponse_Response()
}

type SubscribeResponse_Update struct {
	Update *Notification `protobuf:"bytes,1,opt,name=update,oneof"`
}
type SubscribeResponse_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeResponse_SyncResponse struct {
	SyncResponse bool `protobuf:"varint,3,opt,name=sync_response,json=syncResponse,oneof"`
}
type SubscribeResponse_Error struct {
	Error *Error `protobuf:"bytes,4,opt,name=error,oneof"`
}

func (*SubscribeResponse_Update) isSubscribeResponse_Response()       {}
func (*SubscribeResponse_Heartbeat) isSubscribeResponse_Response()    {}
func (*SubscribeResponse_SyncResponse) isSubscribeResponse_Response() {}
func (*SubscribeResponse_Error) isSubscribeResponse_Response()        {}

func (m *SubscribeResponse) GetResponse() isSubscribeResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SubscribeResponse) GetUpdate() *Notification {
	if x, ok := m.GetResponse().(*SubscribeResponse_Update); ok {
		return x.Update
	}
	return nil
}

func (m *SubscribeResponse) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetResponse().(*SubscribeResponse_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeResponse) GetSyncResponse() bool {
	if x, ok := m.GetResponse().(*SubscribeResponse_SyncResponse); ok {
		return x.SyncResponse
	}
	return false
}

func (m *SubscribeResponse) GetError() *Error {
	if x, ok := m.GetResponse().(*SubscribeResponse_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeResponse_OneofMarshaler, _SubscribeResponse_OneofUnmarshaler, _SubscribeResponse_OneofSizer, []interface{}{
		(*SubscribeResponse_Update)(nil),
		(*SubscribeResponse_Heartbeat)(nil),
		(*SubscribeResponse_SyncResponse)(nil),
		(*SubscribeResponse_Error)(nil),
	}
}

func _SubscribeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case *SubscribeResponse_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeResponse_SyncResponse:
		t := uint64(0)
		if x.SyncResponse {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *SubscribeResponse_Error:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SubscribeResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _SubscribeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeResponse)
	switch tag {
	case 1: // response.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Notification)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Update{msg}
		return true, err
	case 2: // response.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Heartbeat{msg}
		return true, err
	case 3: // response.sync_response
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Response = &SubscribeResponse_SyncResponse{x != 0}
		return true, err
	case 4: // response.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		s := proto.Size(x.Update)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_SyncResponse:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *SubscribeResponse_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SubscriptionList is used within a Subscribe message to specify the list of
// paths that the client wishes to subscribe to. The message consists of a
// list of (possibly prefixed) paths, and options that relate to the
// subscription.
// Reference: gNMI Specification Section 3.5.1.2
type SubscriptionList struct {
	Prefix       *Path           `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Subscription []*Subscription `protobuf:"bytes,2,rep,name=subscription" json:"subscription,omitempty"`
	// Whether target defined aliases are allowed within the subscription.
	UseAliases bool                  `protobuf:"varint,3,opt,name=use_aliases,json=useAliases" json:"use_aliases,omitempty"`
	Qos        *QOSMarking           `protobuf:"bytes,4,opt,name=qos" json:"qos,omitempty"`
	Mode       SubscriptionList_Mode `protobuf:"varint,5,opt,name=mode,enum=smetric_rpc.SubscriptionList_Mode" json:"mode,omitempty"`
	UseModel   *ModelData            `protobuf:"bytes,6,opt,name=use_model,json=useModel" json:"use_model,omitempty"`
}

func (m *SubscriptionList) Reset()                    { *m = SubscriptionList{} }
func (m *SubscriptionList) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionList) ProtoMessage()               {}
func (*SubscriptionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SubscriptionList) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SubscriptionList) GetSubscription() []*Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *SubscriptionList) GetUseAliases() bool {
	if m != nil {
		return m.UseAliases
	}
	return false
}

func (m *SubscriptionList) GetQos() *QOSMarking {
	if m != nil {
		return m.Qos
	}
	return nil
}

func (m *SubscriptionList) GetMode() SubscriptionList_Mode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionList_STREAM
}

func (m *SubscriptionList) GetUseModel() *ModelData {
	if m != nil {
		return m.UseModel
	}
	return nil
}

// Subscription is a single request within a SubscriptionList. The path
// specified is interpreted (along with the prefix) as the elements of the data
// tree that the client is subscribing to. The mode determines how the target
// should trigger updates to be sent.
// Reference: gNMI Specification Section 3.5.1.3
type Subscription struct {
	Path           *Path                 `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Mode           SubscriptionMode      `protobuf:"varint,2,opt,name=mode,enum=smetric_rpc.SubscriptionMode" json:"mode,omitempty"`
	Op             SubscriptionOperation `protobuf:"varint,3,opt,name=op,enum=smetric_rpc.SubscriptionOperation" json:"op,omitempty"`
	SampleInterval uint64                `protobuf:"varint,4,opt,name=sample_interval,json=sampleInterval" json:"sample_interval,omitempty"`
	// Indicates whether values that not changed should be sent in a SAMPLE
	// subscription.
	SuppressRedundant bool `protobuf:"varint,5,opt,name=suppress_redundant,json=suppressRedundant" json:"suppress_redundant,omitempty"`
	// Specifies the maximum allowable silent period in nanoseconds when
	// suppress_redundant is in use. The target should send a value at least once
	// in the period specified.
	HeartbeatInterval uint64   `protobuf:"varint,6,opt,name=heartbeat_interval,json=heartbeatInterval" json:"heartbeat_interval,omitempty"`
	Encoding          Encoding `protobuf:"varint,7,opt,name=encoding,enum=smetric_rpc.Encoding" json:"encoding,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Subscription) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Subscription) GetMode() SubscriptionMode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionMode_TARGET_DEFINED
}

func (m *Subscription) GetOp() SubscriptionOperation {
	if m != nil {
		return m.Op
	}
	return SubscriptionOperation_SUBSCRIBE_ADD
}

func (m *Subscription) GetSampleInterval() uint64 {
	if m != nil {
		return m.SampleInterval
	}
	return 0
}

func (m *Subscription) GetSuppressRedundant() bool {
	if m != nil {
		return m.SuppressRedundant
	}
	return false
}

func (m *Subscription) GetHeartbeatInterval() uint64 {
	if m != nil {
		return m.HeartbeatInterval
	}
	return 0
}

func (m *Subscription) GetEncoding() Encoding {
	if m != nil {
		return m.Encoding
	}
	return Encoding_JSON
}

// QOSMarking specifies the DSCP value to be set on transmitted telemetry
// updates from the target.
// Reference: gNMI Specification Section 3.5.1.2
type QOSMarking struct {
	Marking uint32 `protobuf:"varint,1,opt,name=marking" json:"marking,omitempty"`
}

func (m *QOSMarking) Reset()                    { *m = QOSMarking{} }
func (m *QOSMarking) String() string            { return proto.CompactTextString(m) }
func (*QOSMarking) ProtoMessage()               {}
func (*QOSMarking) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *QOSMarking) GetMarking() uint32 {
	if m != nil {
		return m.Marking
	}
	return 0
}

// Alias specifies a data tree path, and an associated string which defines an
// alias which is to be used for this path in the context of the RPC. The alias
// is specified as a string which is prefixed with "#" to disambiguate it from
// data tree element paths.
// Reference: gNMI Specification Section 2.4.2
type Alias struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Alias string `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
}

func (m *Alias) Reset()                    { *m = Alias{} }
func (m *Alias) String() string            { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()               {}
func (*Alias) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Alias) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Alias) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

// AliasList specifies a list of aliases. It is used in a SubscribeRequest for
// a client to create a set of aliases that the target is to utilize.
// Reference: gNMI Specification Section 3.5.1.6
type AliasList struct {
	Alias []*Alias `protobuf:"bytes,1,rep,name=alias" json:"alias,omitempty"`
}

func (m *AliasList) Reset()                    { *m = AliasList{} }
func (m *AliasList) String() string            { return proto.CompactTextString(m) }
func (*AliasList) ProtoMessage()               {}
func (*AliasList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AliasList) GetAlias() []*Alias {
	if m != nil {
		return m.Alias
	}
	return nil
}

// UDPWrapper adds metadata necessary for encapsulating a list of notifications
// into a UDP packet.  It adds the ability to identify the target that
// originated the Notifications, detect packet loss, and identify latency
// introduced by the target wrapping notifications.
//
// The target should keep the total size of a serialized UDPWrapper message
// small enough to not cause IP packet fragmentation.
type UDPWrapper struct {
	// ID Identifies the target (e.g., Loopback IP address, linecard, ...)
	// TODO(borman): Add examples.  Perhaps agent/module/submodule for vendor.
	Id *Path `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Optional Epoch time of when the message is queued for transmit.
	// Useful to quantify delay between message generation and transmission.
	TransmitTimestamp uint64 `protobuf:"varint,2,opt,name=transmit_timestamp,json=transmitTimestamp" json:"transmit_timestamp,omitempty"`
	// The sequence_number must start at 1 and increment by 1 for each new packet
	// sent.  A client may use this to determine if a packet was lost.
	SequenceNumber uint64          `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number,omitempty"`
	Notification   []*Notification `protobuf:"bytes,4,rep,name=notification" json:"notification,omitempty"`
}

func (m *UDPWrapper) Reset()                    { *m = UDPWrapper{} }
func (m *UDPWrapper) String() string            { return proto.CompactTextString(m) }
func (*UDPWrapper) ProtoMessage()               {}
func (*UDPWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *UDPWrapper) GetId() *Path {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *UDPWrapper) GetTransmitTimestamp() uint64 {
	if m != nil {
		return m.TransmitTimestamp
	}
	return 0
}

func (m *UDPWrapper) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *UDPWrapper) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

var E_GnmiService = &proto.ExtensionDesc{
	ExtendedType:  (*google_protobuf1.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "smetric_rpc.gnmi_service",
	Tag:           "bytes,1001,opt,name=gnmi_service,json=gnmiService",
	Filename:      "github.com/richard28530/streaming_telemetry/rpc/gnmi.proto",
}

func init() {
	proto.RegisterType((*ModelData)(nil), "smetric_rpc.ModelData")
	proto.RegisterType((*Notification)(nil), "smetric_rpc.Notification")
	proto.RegisterType((*Update)(nil), "smetric_rpc.Update")
	proto.RegisterType((*Path)(nil), "smetric_rpc.Path")
	proto.RegisterType((*Value)(nil), "smetric_rpc.Value")
	proto.RegisterType((*Error)(nil), "smetric_rpc.Error")
	proto.RegisterType((*SubscribeRequest)(nil), "smetric_rpc.SubscribeRequest")
	proto.RegisterType((*Poll)(nil), "smetric_rpc.Poll")
	proto.RegisterType((*Heartbeat)(nil), "smetric_rpc.Heartbeat")
	proto.RegisterType((*SubscribeResponse)(nil), "smetric_rpc.SubscribeResponse")
	proto.RegisterType((*SubscriptionList)(nil), "smetric_rpc.SubscriptionList")
	proto.RegisterType((*Subscription)(nil), "smetric_rpc.Subscription")
	proto.RegisterType((*QOSMarking)(nil), "smetric_rpc.QOSMarking")
	proto.RegisterType((*Alias)(nil), "smetric_rpc.Alias")
	proto.RegisterType((*AliasList)(nil), "smetric_rpc.AliasList")
	proto.RegisterType((*UDPWrapper)(nil), "smetric_rpc.UDPWrapper")
	proto.RegisterEnum("smetric_rpc.Encoding", Encoding_name, Encoding_value)
	proto.RegisterEnum("smetric_rpc.SubscriptionMode", SubscriptionMode_name, SubscriptionMode_value)
	proto.RegisterEnum("smetric_rpc.SubscriptionOperation", SubscriptionOperation_name, SubscriptionOperation_value)
	proto.RegisterEnum("smetric_rpc.SubscriptionList_Mode", SubscriptionList_Mode_name, SubscriptionList_Mode_value)
	proto.RegisterExtension(E_GnmiService)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GNMI service

type GNMIClient interface {
	// Subscribe allows a client to request the target to send it values
	// of particular paths within the data tree. These values may be streamed
	// at a particular cadence (STREAM), sent one off on a long-lived channel
	// (POLL), or sent as a one-off retrieval (ONCE).
	// Reference: gNMI Specification Section 3.5
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (GNMI_SubscribeClient, error)
}

type gNMIClient struct {
	cc *grpc.ClientConn
}

func NewGNMIClient(cc *grpc.ClientConn) GNMIClient {
	return &gNMIClient{cc}
}

func (c *gNMIClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (GNMI_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GNMI_serviceDesc.Streams[0], c.cc, "/smetric_rpc.gNMI/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &gNMISubscribeClient{stream}
	return x, nil
}

type GNMI_SubscribeClient interface {
	Send(*SubscribeRequest) error
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type gNMISubscribeClient struct {
	grpc.ClientStream
}

func (x *gNMISubscribeClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gNMISubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GNMI service

type GNMIServer interface {
	// Subscribe allows a client to request the target to send it values
	// of particular paths within the data tree. These values may be streamed
	// at a particular cadence (STREAM), sent one off on a long-lived channel
	// (POLL), or sent as a one-off retrieval (ONCE).
	// Reference: gNMI Specification Section 3.5
	Subscribe(GNMI_SubscribeServer) error
}

func RegisterGNMIServer(s *grpc.Server, srv GNMIServer) {
	s.RegisterService(&_GNMI_serviceDesc, srv)
}

func _GNMI_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GNMIServer).Subscribe(&gNMISubscribeServer{stream})
}

type GNMI_SubscribeServer interface {
	Send(*SubscribeResponse) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type gNMISubscribeServer struct {
	grpc.ServerStream
}

func (x *gNMISubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gNMISubscribeServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GNMI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "smetric_rpc.gNMI",
	HandlerType: (*GNMIServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _GNMI_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/richard28530/streaming_telemetry/rpc/gnmi.proto",
}

func init() {
	proto.RegisterFile("github.com/richard28530/streaming_telemetry/rpc/gnmi.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1222 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xef, 0xd9, 0x67, 0xc7, 0x37, 0x71, 0x8a, 0xb3, 0xb4, 0xc5, 0x44, 0x05, 0xca, 0x49, 0xa5,
	0x21, 0x08, 0x3b, 0x75, 0x54, 0x54, 0x55, 0x2a, 0xd4, 0x8e, 0x9d, 0xc6, 0x28, 0xb1, 0xc3, 0xda,
	0x29, 0xea, 0x03, 0xb2, 0xd6, 0xf6, 0xc6, 0x39, 0x61, 0xdf, 0x5d, 0x77, 0xcf, 0x15, 0xe1, 0xfb,
	0xc1, 0x03, 0x1f, 0x80, 0x37, 0xc4, 0x33, 0x8f, 0x7c, 0x03, 0x66, 0xf7, 0xfe, 0xf8, 0x8e, 0xfc,
	0xa1, 0xe2, 0xc1, 0xd2, 0xed, 0xcc, 0x6f, 0x66, 0xe7, 0xcf, 0x6f, 0x66, 0x0d, 0xcf, 0x66, 0x4e,
	0x70, 0xbe, 0x1c, 0xd7, 0x26, 0xde, 0xa2, 0x2e, 0x9c, 0xc9, 0x39, 0x13, 0xd3, 0xc6, 0xd3, 0x27,
	0x7b, 0xbb, 0x75, 0x19, 0x08, 0xce, 0x16, 0x8e, 0x3b, 0x1b, 0x05, 0x7c, 0xce, 0x17, 0x3c, 0x10,
	0x17, 0x75, 0xe1, 0x4f, 0xea, 0x33, 0x77, 0xe1, 0xd4, 0x7c, 0xe1, 0x05, 0x1e, 0x59, 0x97, 0x4a,
	0xec, 0x4c, 0x46, 0x28, 0xdf, 0xaa, 0xa7, 0x1c, 0xcd, 0xbc, 0x39, 0x73, 0x67, 0x75, 0x8d, 0x1a,
	0x2f, 0xcf, 0xea, 0x7e, 0x70, 0xe1, 0x73, 0x59, 0x67, 0xee, 0x85, 0xfa, 0x85, 0xd6, 0x5b, 0xdf,
	0x64, 0x0c, 0xbc, 0xd9, 0x9c, 0xaf, 0x0c, 0xa4, 0x98, 0x5c, 0x92, 0x4d, 0xb9, 0x9c, 0x08, 0xc7,
	0x0f, 0x3c, 0x11, 0x3a, 0xb0, 0x7f, 0x00, 0xeb, 0xd8, 0x9b, 0xf2, 0x79, 0x9b, 0x05, 0x8c, 0x10,
	0x30, 0x5d, 0xb6, 0xe0, 0x55, 0xe3, 0x81, 0xb1, 0x6d, 0x51, 0xfd, 0x4d, 0x6c, 0x28, 0x7b, 0x62,
	0xc6, 0x5c, 0xe7, 0x67, 0x16, 0x38, 0x9e, 0x5b, 0xcd, 0x69, 0x5d, 0x46, 0x46, 0xaa, 0xb0, 0xf6,
	0x96, 0x0b, 0xa9, 0xd4, 0x79, 0xad, 0x8e, 0x8f, 0xf6, 0x2f, 0x06, 0x94, 0x7b, 0x5e, 0xe0, 0x9c,
	0x39, 0x93, 0x10, 0x7a, 0x1f, 0xac, 0xc0, 0x59, 0x70, 0x19, 0xb0, 0x85, 0xaf, 0xef, 0xc9, 0xd3,
	0x95, 0x80, 0x7c, 0x0e, 0x45, 0x5f, 0xf0, 0x33, 0xe7, 0x27, 0x7d, 0xcd, 0x7a, 0x63, 0xb3, 0x96,
	0xaa, 0x4e, 0xed, 0x84, 0x05, 0xe7, 0x34, 0x02, 0x90, 0x3b, 0x50, 0x60, 0x73, 0x87, 0xc9, 0xe8,
	0xc6, 0xf0, 0x40, 0xbe, 0x80, 0xe2, 0xd2, 0x9f, 0xb2, 0x80, 0x57, 0xcd, 0x07, 0x79, 0x74, 0xf0,
	0x7e, 0xc6, 0xc1, 0xa9, 0x56, 0xd1, 0x08, 0xa2, 0x6e, 0xc3, 0xcc, 0x39, 0x82, 0x0b, 0x1a, 0x7c,
	0xd5, 0x6d, 0x21, 0xc0, 0x7e, 0x0d, 0xc5, 0xd0, 0x98, 0x3c, 0x04, 0xd3, 0x47, 0x8d, 0x8e, 0xfd,
	0x4a, 0x13, 0xad, 0x26, 0xdb, 0x50, 0x78, 0xcb, 0xe6, 0x4b, 0x1e, 0x25, 0x42, 0x32, 0xb8, 0x57,
	0x4a, 0x43, 0x43, 0x80, 0xfd, 0x14, 0x4c, 0x65, 0xa7, 0x8a, 0xa8, 0x39, 0xe2, 0x06, 0xe8, 0x3b,
	0xaf, 0x8a, 0x18, 0x1d, 0xc9, 0x3d, 0x28, 0x7a, 0xc2, 0x99, 0x39, 0x71, 0xf1, 0xa3, 0x93, 0x7d,
	0x08, 0x05, 0xed, 0x49, 0xd5, 0x22, 0xbc, 0x4c, 0x05, 0x55, 0x8e, 0x1c, 0x63, 0x7a, 0xa6, 0xa2,
	0x8c, 0x36, 0xba, 0xdd, 0xb8, 0x9b, 0x89, 0xa0, 0xe3, 0x4e, 0xbc, 0x29, 0xf2, 0x92, 0x6a, 0x88,
	0x3d, 0x82, 0x42, 0x47, 0x08, 0x4f, 0x28, 0x06, 0xa0, 0x22, 0x74, 0xb4, 0x41, 0xf5, 0xb7, 0x0a,
	0x0c, 0xfb, 0x23, 0xd9, 0x8c, 0x47, 0xf7, 0xc7, 0x47, 0x4c, 0xd2, 0xc4, 0x9a, 0x30, 0xdd, 0x82,
	0xf5, 0xc6, 0x9d, 0x5a, 0xc8, 0xb6, 0x5a, 0xcc, 0xb6, 0x5a, 0xd3, 0xbd, 0xa0, 0x1a, 0x61, 0xff,
	0x6d, 0x40, 0x65, 0xb0, 0x1c, 0x2b, 0xf2, 0x8d, 0x39, 0xe5, 0x6f, 0x96, 0xd8, 0x70, 0xf2, 0x1c,
	0x2c, 0x19, 0xcb, 0xa2, 0x7a, 0x7e, 0x94, 0x89, 0x32, 0xb2, 0xf0, 0x15, 0x73, 0x8e, 0x1c, 0x19,
	0x1c, 0xde, 0xa2, 0x2b, 0x0b, 0xf2, 0x15, 0x58, 0xe7, 0x9c, 0x89, 0x60, 0xcc, 0x59, 0x10, 0x95,
	0xf9, 0x5e, 0xc6, 0xfc, 0x30, 0xd6, 0x2a, 0xbb, 0x04, 0x4a, 0x1e, 0x61, 0x07, 0xbd, 0xf9, 0x3c,
	0x8a, 0xfa, 0x5f, 0x1d, 0x44, 0x05, 0xa2, 0x35, 0x80, 0x34, 0x60, 0x4d, 0xb3, 0x8a, 0x4b, 0x64,
	0xd3, 0x65, 0xf7, 0x4d, 0xa5, 0x8b, 0xc2, 0x8a, 0x81, 0x2d, 0x0b, 0xd6, 0x44, 0x98, 0x9e, 0x5d,
	0xc4, 0xc6, 0xa2, 0x1b, 0xfb, 0x11, 0x58, 0x49, 0x24, 0x64, 0x0b, 0x4a, 0x8e, 0x1b, 0x70, 0x81,
	0x2d, 0xd2, 0x29, 0x9b, 0x34, 0x39, 0xdb, 0x7f, 0x1a, 0xb0, 0x99, 0x2a, 0x92, 0xf4, 0x3d, 0x57,
	0x72, 0xb2, 0x97, 0x50, 0x3a, 0x2c, 0xd1, 0x87, 0x99, 0x20, 0xd2, 0xc3, 0x85, 0x71, 0xc4, 0xd4,
	0xfe, 0xbf, 0xb5, 0x79, 0x08, 0x1b, 0xf2, 0xc2, 0x45, 0x48, 0x74, 0xbb, 0x2e, 0x52, 0x09, 0x31,
	0x65, 0x25, 0x4e, 0x62, 0xda, 0x81, 0x02, 0x57, 0x7c, 0x89, 0xea, 0x92, 0x65, 0xb7, 0x66, 0x12,
	0x9a, 0x84, 0x90, 0x16, 0x40, 0x29, 0xf6, 0x66, 0xff, 0x91, 0x4b, 0x68, 0x90, 0x34, 0x35, 0x35,
	0xf4, 0xc6, 0x7f, 0x0d, 0xfd, 0x73, 0x28, 0xcb, 0x94, 0x39, 0x66, 0x96, 0xbf, 0x54, 0x91, 0xb4,
	0x7f, 0x9a, 0x81, 0x93, 0x4f, 0x60, 0x7d, 0x29, 0xf9, 0x28, 0x6e, 0xaa, 0xce, 0x8d, 0x02, 0x8a,
	0x9a, 0xa1, 0x04, 0x43, 0xc9, 0xbf, 0xf1, 0xe2, 0x6e, 0x7f, 0x90, 0x71, 0xfb, 0x5d, 0x7f, 0x70,
	0xcc, 0xc4, 0x8f, 0x6a, 0x66, 0x14, 0x06, 0x2b, 0x6c, 0x2e, 0xd4, 0xa4, 0x14, 0xf4, 0x74, 0xd9,
	0x37, 0xf2, 0xb6, 0xa6, 0x56, 0x2c, 0xd5, 0x78, 0x6c, 0xa7, 0xa5, 0x62, 0x50, 0xdf, 0xf3, 0x6a,
	0xf1, 0x8a, 0xce, 0x24, 0xeb, 0x98, 0x96, 0x10, 0xa8, 0x4f, 0xf6, 0x67, 0x60, 0xaa, 0x0f, 0x02,
	0x50, 0x1c, 0x0c, 0x69, 0xa7, 0x79, 0x5c, 0xb9, 0x45, 0x4a, 0x60, 0xf6, 0x7b, 0xfb, 0x9d, 0x8a,
	0xa1, 0xbe, 0x4e, 0xfa, 0x47, 0x47, 0x95, 0x9c, 0xfd, 0x7b, 0x0e, 0xca, 0xe9, 0xcb, 0xdf, 0x75,
	0x5b, 0x3d, 0x8e, 0x92, 0x09, 0x57, 0xc5, 0xf5, 0x43, 0x98, 0xca, 0xa3, 0x01, 0x39, 0xcf, 0xd7,
	0x25, 0xbc, 0x29, 0xfb, 0xbe, 0xcf, 0x85, 0xe6, 0x26, 0x45, 0x34, 0x4e, 0xde, 0x7b, 0x12, 0xd7,
	0xfc, 0x9c, 0x8f, 0x92, 0x19, 0x30, 0xf5, 0x0c, 0xdc, 0x0e, 0xc5, 0xdd, 0x48, 0x4a, 0xbe, 0x04,
	0x22, 0x97, 0x3e, 0x36, 0x5d, 0x4a, 0xa4, 0xe2, 0x74, 0xe9, 0x4e, 0x19, 0xae, 0xc5, 0x82, 0xee,
	0xd7, 0x66, 0xac, 0xa1, 0xb1, 0x42, 0xc1, 0x13, 0x0a, 0xaf, 0x5c, 0x17, 0xb5, 0xeb, 0xcd, 0x44,
	0x93, 0x78, 0x7f, 0x0c, 0x25, 0x1e, 0xed, 0xbf, 0xea, 0xda, 0x4d, 0xcb, 0x31, 0x81, 0x61, 0x03,
	0x60, 0x45, 0x00, 0xbd, 0x11, 0xc3, 0xcf, 0x68, 0x51, 0xc6, 0x47, 0xbb, 0x0d, 0x05, 0xcd, 0xa5,
	0x77, 0x2d, 0x7c, 0xf2, 0x8a, 0xe5, 0x52, 0xaf, 0x98, 0xfd, 0x04, 0xac, 0x64, 0xb9, 0xa8, 0x97,
	0x24, 0x84, 0x18, 0x9a, 0xec, 0xe4, 0xf2, 0x0e, 0x8a, 0xcd, 0x7e, 0x35, 0x00, 0x4e, 0xdb, 0x27,
	0xdf, 0x0b, 0xe6, 0x63, 0xd9, 0xc9, 0xa7, 0x90, 0x73, 0xa6, 0xd7, 0x07, 0x80, 0x4a, 0x55, 0xb8,
	0x40, 0x30, 0x57, 0x2e, 0x9c, 0x60, 0xb4, 0x7a, 0x96, 0x73, 0x61, 0xe1, 0x62, 0xcd, 0x30, 0x79,
	0x9e, 0x55, 0xff, 0xd4, 0x72, 0x73, 0x27, 0x7c, 0xe4, 0x2e, 0x17, 0x63, 0x2e, 0x34, 0x01, 0x54,
	0xff, 0x22, 0x71, 0x4f, 0x4b, 0xd5, 0x9c, 0xba, 0xa9, 0xc5, 0x14, 0x3d, 0xc6, 0xd7, 0x6f, 0x2e,
	0x9a, 0x81, 0xef, 0xb4, 0xa1, 0x14, 0xf7, 0x40, 0x91, 0xfb, 0xdb, 0x41, 0xbf, 0x87, 0x84, 0xb7,
	0xa0, 0xd0, 0x7a, 0x3d, 0xec, 0x0c, 0x90, 0xf1, 0xf8, 0x79, 0x42, 0xfb, 0xc3, 0x7e, 0x25, 0xa7,
	0x3e, 0x9b, 0x83, 0xfd, 0x6e, 0xb7, 0x92, 0x27, 0x1b, 0x60, 0x29, 0xe8, 0xa8, 0xdb, 0x19, 0x1e,
	0x54, 0xcc, 0x9d, 0x66, 0x76, 0xd7, 0xe8, 0x01, 0x22, 0x70, 0x7b, 0xd8, 0xa4, 0x2f, 0x3b, 0xc3,
	0x51, 0xbb, 0x73, 0xd0, 0xed, 0x75, 0xda, 0xe8, 0x17, 0xcd, 0xd0, 0x68, 0xff, 0xb0, 0xd9, 0x7b,
	0xa9, 0xa6, 0x49, 0xcd, 0x58, 0xf3, 0xf8, 0xe4, 0xa8, 0x53, 0xc9, 0xed, 0xbc, 0x80, 0xbb, 0x57,
	0xb2, 0x99, 0x6c, 0xc2, 0xc6, 0xe0, 0xb4, 0x35, 0xd8, 0xa7, 0xdd, 0x56, 0x67, 0xd4, 0x6c, 0x2b,
	0x37, 0x77, 0xf0, 0xba, 0x44, 0xb4, 0xdf, 0xc4, 0xd1, 0x3c, 0xaa, 0x18, 0x8d, 0x57, 0x60, 0xce,
	0x7a, 0xc7, 0x5d, 0xd2, 0x03, 0x2b, 0x59, 0xed, 0xe4, 0xca, 0x01, 0x4b, 0xde, 0xc5, 0xad, 0x8f,
	0xaf, 0x53, 0x87, 0x5b, 0x74, 0xdb, 0xd8, 0x35, 0x9e, 0xbd, 0x80, 0xb2, 0xfa, 0x13, 0x39, 0x92,
	0x48, 0x69, 0x67, 0xc2, 0xc9, 0xfd, 0x4b, 0x8f, 0xef, 0x81, 0x33, 0xe7, 0x7d, 0x1d, 0xb6, 0xac,
	0xfe, 0xb5, 0xa6, 0xe9, 0xb5, 0xae, 0x4c, 0x06, 0xa1, 0x45, 0xab, 0xf4, 0xdb, 0xd7, 0x85, 0xdd,
	0x5a, 0xa3, 0xb6, 0x3b, 0x2e, 0x6a, 0x9b, 0xbd, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xc3,
	0xc7, 0xb9, 0xc7, 0x0a, 0x00, 0x00,
}
